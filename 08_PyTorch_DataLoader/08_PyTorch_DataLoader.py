# -*- coding: utf-8 -*-
"""PyTorchZeroToAll - Lecture 08: PyTorch DataLoader.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w8KyYTj26Ao2X9-uYXaA3atoqzROI6QE

# Lecture 08: PyTorch DataLoader
"""

import numpy as np
import torch
from torch.autograd import Variable
from torch.utils.data import Dataset, DataLoader

class DiabetesDataset(Dataset):
    # 1. download, read data, etc.
    def __init__(self):
        xy = np.loadtxt("data-diabetes.csv", delimiter=",", dtype=np.float32)
        self.len = xy.shape[0]
        self.x_data = torch.from_numpy(xy[:, 0:-1])
        self.y_data = torch.from_numpy(xy[:, [-1]])

    # 2. return one item on the index
    def __getitem__(self, index):
        return self.x_data[index], self.y_data[index]

    # 3. return the data length
    def __len__(self):
        return self.len

dataset = DiabetesDataset()
train_loader = DataLoader(dataset=dataset,
                          batch_size=32,
                          shuffle=True,
                          num_workers=2)

class Model(torch.nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.l1 = torch.nn.Linear(8, 6)
        self.l2 = torch.nn.Linear(6, 4)
        self.l3 = torch.nn.Linear(4, 1)

        self.sigmoid = torch.nn.Sigmoid()

    def forward(self, x):
        out1 = self.sigmoid(self.l1(x))
        out2 = self.sigmoid(self.l2(out1))
        y_pred = self.sigmoid(self.l3(out2))

        return y_pred

model = Model()

criterion = torch.nn.BCELoss(reduction='mean')
optimizer = torch.optim.SGD(model.parameters(), lr=0.01)

# Training loop
epochs = 2
for epoch in range(1, epochs+1):
    for i, data in enumerate(train_loader, 0):
        # get the inputs
        inputs, labels = data

        # wrap them in Variable
        inputs, labels = Variable(inputs), Variable(labels)

        # Forward pass: Compute predicted y by passing x to the model
        y_pred = model(inputs)


        # Compute and print loss
        loss = criterion(y_pred, labels)
        print(f"{epoch} Epoch {i} Iters : loss = {loss.item()}")

        # Zero gradients, perform a backward pass, and update the weigths.
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    print()

"""## The following dataset loaders are [available](https://pytorch.org/vision/stable/datasets.html)
- MNIST and FashionMNIST
- COCO (Captioning and Detection)
- LSUN Classification
- ImageFolder
- Imagenet
- CIFAR10 and CIFAR100
- STL10
- SVHN
- PhotoTour

### MNIST dataset loading
"""

from torchvision import datasets
from torchvision.transforms import ToTensor

# MNIST Dataset
train_dataset = datasets.MNIST(root="./data/",
                               train=True,
                               transform=ToTensor(),
                               download=True)

test_dataset = datasets.MNIST(root="./data/",
                              train=False,
                              transform=ToTensor())

batch_size = 32

# Data Loader (Input Pipeline)
train_loader = DataLoader(dataset=train_dataset,
                          batch_size=batch_size,
                          shuffle=True)
test_loader = DataLoader(dataset=test_dataset,
                         batch_size=batch_size,
                         shuffle=False)

for batch_idx, (data, target) in enumerate(train_loader):
    data, target = Variable(data), Variable(target)
    # ...
    
# https://github.com/yunjey/pytorch-tutorial/blob/master/tutorials/01-basics/logistic_regression/main.py